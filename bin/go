#!/bin/bash
##### helper functions #####
autoinstall_wallah() {
  [[ -f wallah/bin/install_node ]] && return
  git submodule update --init --depth 1
}

autoinstall_npm_dependencies() {
  autoinstall_wallah
  ./wallah/bin/install_node
  [[ -d node_modules/express ]] && return
  npm install
}

autoinstall_bower_dependencies() {
  [[ -d bower_components/angular ]] && return
  ./node_modules/.bin/bower install
}

doc() {
  help="${help}$1
"
}

#The "help" variable gets extended by the "doc" function
#inline below as needed sort of javadoc/python decorator style
help=""
usage() {
  cat <<EOF
Usage: $(basename $0) <subcommand> [args…]

Purpose of $(basename $0) script
--------------------
* entrypoint script for common commands
* Automatically installs development prerequisites
* Ensures the correct PATH environment variable
* commands are grouped by lifecycle and described in more detail below

Development Commands
--------------------
${help}
EOF
}

doc "* express: start the express server"
task::express() {
  autoinstall_npm_dependencies
  autoinstall_bower_dependencies
  node-dev --debug=9091 app/server | tee -a logs/mjournal.log
}

doc "  * aliased as 'start' command as well"
task::start() {
  task::express
}

doc "* test: run all the tests (mocha)"
task::test() {
  set -e
  export NODE_ENV=test
  args="--slow 200 --reporter spec --colors --recursive --check-leaks"
  if [[ "${1}" == "--debug" ]]; then
    args="${args} --timeout 0 --debug-brk=9093"
    shift
  fi
  tests="$@"
  if [[ -z "${tests}" ]]; then
    tests=$(find app -type f -name '*.mocha.js' | xargs)
  fi
  echo -n "wiping test database…"
  app/db/wipe.js
  echo ✓
  echo "mocha tests…"
  mocha ${args} ${tests}
  printf "linting…"
  task::lint
  echo ✓
}

doc "* lint: run eslint code format checker"
task::lint() {
  eslint app bin/render_template
}

_dockerfile() {
  ./bin/render_template deploy/Dockerfile.mustache > Dockerfile
}

doc "* fig: bring up the full system via docker and fig"
task::fig() {
  _dockerfile
  if [[ ! -e fig.yml ]]; then
    #We might be running fig for the very first time,
    #Try to ensure data volumes exist
    source ./bin/provision_stage.sh
  fi
  ./bin/render_template deploy/fig.yml.mustache > fig.yml
  fig "$@"
}

dcip() {
  container=$(docker ps | egrep "\b$1\s*\$" | awk '{print $1}')
  docker inspect -f "{{ .NetworkSettings.IPAddress }}" "${container}"
}

doc "* figlog: tail the log file of the app in the fig container"
task::figlog() {
  chmod 0600 deploy/docker_insecure.key
  ssh \
    -i deploy/docker_insecure.key \
    -o UserKnownHostsFile=/dev/null \
    -o StrictHostKeyChecking=no \
    root@$(dcip mjournal_app_1) \
    tail -f /var/log/app.log
}

doc "
Release Management Commands
-------------------
"

doc "* release_candidate <major|minor|patch>: prepare develop branch for a release tag"
task::release_candidate() {
  set -e
  if [[ $(git status --short | wc -c | tr -d " ") != "0" ]]; then
    echo "Abort: working directory not clean"
    exit 11
  fi
  git checkout develop
  git pull origin master
  npm version "$@"
}

doc "
Deployment Commands
-------------------
"

doc "* clean: delete the build directory"
task::clean() {
  rm Dockerfile fig.yml
}

doc "* build: render the Dockerfile then run a docker build"
task::build() {
  _dockerfile
  exec docker build --tag=mjournal .
}

doc "* tush_production: tag and push a docker build to production"
task::tag_and_push_prod() {
  local base="docker.peterlyons.com:5000/mjournal"
  local build="$1"
  local version="$(./wallah/bin/get_json_value package.json version)"
  docker tag "${build}" "${base}:v${version}"
  docker tag "${build}" "${base}:production"
  docker push "${base}:v${version}"
  docker push "${base}:production"
}

doc "* tag_stage: tag a docker build for stage"
task::tag_stage() {
  local base="docker.stage.peterlyons.com:5000/mjournal"
  local build="$1"
  docker tag "${build}" "${base}:stage"
}

doc "* deploy_stage run the docker build tagged 'stage' on stage docker"
task::deploy_stage() {
  ./bin/prepare_docker_host.sh dbs
}

doc "* deploy_production run the docker build tagged 'production' on prod docker"
task::deploy_production() {
  NODE_ENV=production ./bin/prepare_docker_host.sh mjournal.peterlyons.com
}

##### main code #####
main() {
  cd $(dirname "$0")/..
  PATH="${PATH}:${PWD}/bin"
  PATH="${PATH}:${PWD}/node_modules/.bin"
  PATH="${PATH}:${PWD}/node/bin"
  #Need the basics like dirname et al
  PATH="${PATH}:/usr/bin:/bin"
  export PATH
  task_name="$1"
  if type "task::${task_name}" &>/dev/null; then
    shift
    eval "task::${task_name}" "$@"
  else
    usage "$@"
  fi
}

main "$@"
