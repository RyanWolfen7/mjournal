#!/usr/bin/env bash

# This file should be run as root (via sudo) on the docker host
# after pushing the correct images to the registry
# and copying the config files into /tmp

# FYI here's the docker options we use on stage:
# DOCKER_OPTS="--ip=0.0.0.0 --host=tcp://0.0.0.0:2375 --dns=8.8.8.8 --icc=false --iptables=true --insecure-registry=docker.peterlyons.com:5000"

# Please Use Google Shell Style: https://google.github.io/styleguide/shell.xml

setup_old_docker() {
  # This is the NEW docker signing key for docker-engine
  # apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
  # This is the OLD docker signing key for lxc-docker
  apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9
  echo 'deb https://get.docker.io/ubuntu docker main' > /etc/apt/sources.list.d/docker.list
  apt-get --quiet --quiet --yes update
  apt-get --quiet --yes install apt-transport-https ca-certificates lxc-docker
}

prepare_registry() {
  if ! grep 'docker\.peterlyons\.com' /etc/hosts > /dev/null; then
    echo "loopback hostname for docker registry not set in /etc/hosts. Setting."
    echo 127.0.0.1 docker.peterlyons.com >> /etc/hosts
  fi
}

setup_nginx() {
  apt-get --quiet --yes install nginx-core
  install --owner="www-data" --group=staff --mode=755 --directory \
    /var/www/{{hostname}}
  install --owner=root --group=staff --mode=750 \
    /tmp/nginx_{{appName}} /etc/nginx/sites-enabled/{{hostname}}
}

setup_cron_backups() {
  echo -n "setting up cron backups…"
  install --owner=www-data --group=staff --mode=755 --directory \
    /var/local/{{appName}}
  install --owner=root --group=staff --mode=750 \
    /tmp/backup-{{appName}}-db /etc/cron.daily/backup-{{appName}}-db
}

setup_{{appName}}_config() {
  local config_file=/var/local/{{appName}}/config.js
  readonly config_file

  if [[ ! -e "${config_file}" ]]; then
    install --owner=www-data --group=staff --mode=0460 /dev/null "${config_file}"
    echo "Empty config installed to ${config_file}."
  fi
  chown "www-data:staff" "${config_file}"
  chmod 0460 "${config_file}"
}

docker_clean_rm() {
  local name="$1"
  # This tr -d nonesense is because mustache and docker inspect
  # both use the same {{}} (mustache) delimiter
  set +e
  running=$(docker inspect -f $(echo "{z{.State.Running}z}" | tr -d z) "${name}")
  local exit_code=$?
  set -e
  if [ "${running}" = "true" ]; then
    printf "✓\nstopping %s" "${name}…"
    docker stop "${name}"
  fi
  if [ "${running}" = "<no value>" ]; then
    return
  fi
  if [ ${exit_code} -eq 0 ]; then
    printf "✓\nremoving %s" "${name}…"
    docker rm "${name}"
  fi
  # non-zero exit code from docker inspect probably means doesn't exist
}

stop_containers() {
  #app stops first for clean shutdown
  docker_clean_rm "{{appName}}"
  docker_clean_rm "{{appName}}_db"
}

start_containers() {
  printf "✓\nstarting {{appName}}_db…"
  docker run \
    "--name={{appName}}_db" \
    "--publish={{db.port}}:{{db.port}}" \
    "--volume=/var/local/{{appName}}_db:/var/lib/postgresql/data" \
    "--volume=/var/log/{{appName}}_db:/var/log/postgresql" \
    --detach \
    --restart=always \
    postgres:{{postgres.version}}

  printf "✓\nstarting {{appName}}…"
  docker run \
    "--publish={{port}}:{{port}}" \
    "--name={{appName}}" \
    "--link={{appName}}_db:{{appName}}_db" \
    "--volume=/var/local/{{appName}}:/etc/{{appName}}" \
    "--volume=/var/local/{{appName}}:/var/log/{{appName}}" \
    --detach \
    --restart=on-failure \
    {{{registry}}}/{{appName}}:{{envName}}

  # registry should be running with
  # docker run --detach --restart=always --publish=127.0.0.1:5000:5000 registry
}

main() {
  # Start unofficial bash strict mode boilerplate
  # http://redsymbol.net/articles/unofficial-bash-strict-mode/
  set -o errexit    # always exit on error
  set -o errtrace   # trap errors in functions as well
  set -o pipefail   # don't ignore exit codes when piping output
  set -o posix      # more strict failures in subshells
  # set -x          # enable debugging

  IFS="$(printf "\n\t")"
  # End unofficial bash strict mode boilerplate
  cd "$(dirname "$0")"

  if uname -r | grep boot2docker > /dev/null; then
    # we are on stage
    unset DOCKER_HOST
    prepare_registry
  fi
  setup_old_docker
  setup_nginx
  setup_cron_backups
  setup_{{appName}}_config
  stop_containers
  start_containers
}

main "$@"
